# java.io

用于传输数据的机制。
根据传输方向：输入流、输出流
根据传输形式：字节流、字符流
四个基本流都是抽象类。

## 流中的异常处理

1. 要将流对象放到`try`之外定义并且赋值为`null`，放到`try`之内创建
2. 在关流之前需要判断是否为`null`
3. 关流之后需要将流对象强制置为`null`
4. 写完数据之后需要手动冲刷一次缓冲区。

`FileReader`：没有缓冲区，需要手动提供一个字符数组作为缓冲区来使用。

## 缓冲流

`BufferedReader`：提供了缓冲区，能够实现按行读取的效果。
利用`FileReader`来构建了`BufferedReader`，然后再`BufferedReader`对读取功能做了增强，这种方式称之为**装饰设计模式**：利用了**同类对象**构建自己对象本身，对对象身上的功能做了增强或者改善

`BufferedWriter`提供了一个更大的缓冲区
* 注意：`Java`中的原生的字符流只能操作字符类文件 `txt` `java` `html`等，但是不能读取`office`组件

## 字节流

`FileInputStream`：字节输入流，可以从文件中读取数据
`FileOutputStream`：字节输出流，可以向文件中写数据

* 一般缓冲区的合适大小是10-15M

## 系统流/标准流

系统流都是字节流
`System.in`：标准输入流
`System.out`：标准输出流
`System.err`：标准错误流

## 转换流

字符流和字节流之间用的转换就是转换流。
`OutputStreamWriter`：将字符流转化为字节流 `FileWriter`是它的子类
`InputStreamReader`：将字节流转化为字符流 `FileReader`是它的子类 

## 合并流

`SequenceInputStream`：创建输入流分别指向对应的文件，然后需要创建一个`Vector`集合存放这些输入流，利用`Vector`集合来产生一个`Enumeration`对象，使用`Enumeration`对象来构建合并流，最后利用合并流来读取数据进行合并。

## 序列化/反序列化流

序列化：将对象转化为字节之后进行存储
持久化：将数据存储在硬盘上
反序列化：将字节转化为对象的过程

* 一个对象想要被序列化，那么它所对应的类必须实现接口`Serializable`，这个接口中没有任何的方法和属性，仅仅起**标志性作用**
* 用`static/transient`修饰的属性不会被序列化

如果一个类产生的对象允许被序列化，那么这个时候这个类在编译的时候会根据当前类中的属性自动计算一个**版本号**。当反序列化的时候，拿着对象中的版本号和类中版本号做比较，如果相等，则说明这个对象是这个产生的，可以被反序列化。如果没有手动指定版本号，自动计算版本号，那么就意味着**类每变动一次**，**版本号**就要**重新计算一次**。为了让序列化出去的对象反序列化回来，需要**手动指定版本号** --- 

``` java
private static final long serialVersionUID
```

## Properties

是一个可以**被持久化**的**映射**。键和值的类型都是`String`
`properties`文件的默认编码就是**西欧编码**，当向`properties`文件中存放中文的时候变成了对应的`Unicode`编码

## 单元测试

``` java
import org.junit.Test;
```

* 没有参数
* 无返回值
* 非静态方法