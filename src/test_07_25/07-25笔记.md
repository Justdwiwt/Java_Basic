# java.lang.Thread

## 线程

* **进程**：计算机中正在执行的任务，在CPU上执行和计算
* **线程**：进程中的小任务——多线程
* 一个核上往往只能执行一个进程中的一个线程
* 计算机看起来像是在运行多个进程，实际上是因为在计算机中任务切换速度非常快，超过人的反应。

> 进程的执行在**宏观上并行**，在**微观上串行**。

## 线程的定义

1. 写一个类继承`Thread`类，将要执行的逻辑放到`run`方法中，创建线程对象，调用`start`方法来启动线程执行任务。
2. 写一个类实现`Runnable`接口，重写`run`方法，创建`Runnable`对象，然后将`Runnable`对象作为参数传递到`Thread`对象中，利用`Thread`对象来启动线程。
3. 写一个类实现`Callable`接口，重写`call`方法。

## 多线程的并发安全问题

在多个线程同时执行时，相互抢占资源导致出现了不合常理的数据现象——多线程的并发安全问题。

![](多线程并发.png)

> 多线程在执行的时候是相互抢占，而且抢占是发生在线程执行的每一步过程中。

## 同步锁机制

> 利用`synchronized`同步代码块解决多线程并发安全问题。

* **同步**：一段逻辑在同一时间**只能有一个**线程执行
* **异步**：一段逻辑在同一时间能**有多个**线程执行
* 同步一定安全，安全不一定同步
* 异步不一定不安全，不安全一定异步

> 从微观上而言，同步一定是安全的，安全也一定是同步的。从宏观上，同步一定是安全的，安全不一定是同步的。

* **锁对象**：要求锁对象要被所有的线程都认识
    * **共享对象**
    * **类的字节码**
        * 方法区被线程所共享
    * `this`
        * 同一个对象开启多个线程

> 堆内存和方法区被线程共享

> 栈内存，本地方法栈，PC计数器是每个线程所独有的

* 如果同步方法是一个**非静态**方法，那么以`this`作为锁对象
* 如果同步方法是一个**静态**方法，那么以当前类作为锁对象

## 死锁

由于锁之间相互嵌套并且锁对象不同导致线程之间相互锁死，致使代码无法继续往下执行

* 避免死锁：统一锁对象，减少锁的嵌套

## 活锁

这个资源没有被任何的线程持有占用，导致程序无法往下执行

## 等待唤醒机制

使用`wait`和`notify`来调节线程的执行顺序

> 等待唤醒机制必须结合锁来使用，而且锁对象是谁就用谁进行等待唤醒

## 线程的状态

![](线程的状态.png)

## 线程的优先级

线程的优先等级为：1-10
理论上，数字越大优先级越高，抢占到资源的概率就越大
实际上，相邻的两个优先级的差别非常不明显。如果优先级差到**5个单位及以上**，则结果会相对明显一点点

## 守护线程

守护别的线程。**只要被守护的线程结束，那么无论守护线程完成与否都会结束。**
在线程中，一个线程要么是**守护线程**，要么是**被守护的线程**。

> 当最后一个被守护的线程结束才会导致所有的守护线程结束——`GC`

## 启动线程

1. 用户请求创建
2. 系统自启
3. 被其他线程启动

## 线程结束

1. 正常执行结束
2. 被其他请求强制结束
3. 执行中出现异常或者错误

## 单例模式

* 设计模式：在软件开发工程中使用的常见的解决问题的方式

> 在全局中只存在一个实例的现象

* 饿汉式：会增加类的加载时间，能够避免并发问题
* 懒汉式：减少加载时间，会导致多线程的并发安全问题